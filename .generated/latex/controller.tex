\documentclass[a4paper]{article}
\usepackage{longtable}
\usepackage[color]{vdmlisting}
\usepackage{fullpage}
\usepackage{hyperref}
\begin{document}
\title{}
\author{}
\begin{vdm_al}
class controller
types
public location = real * real * real;
public parkingLot ::
        car : [car]
        pos : location
        typeOfSlot : <electric> | <gas>
        time : nat
instance variables
    io : IO := new IO();
    public dimensions: nat := 2;
    maxCapacity: nat := (dimensions**3);

    fee: real :=10; --  50% added to the price of parking
    electricParkingPrice: real := 1.0;
    gasParkingPrice: real := 5.0;

    
    public gasSlots : map location to parkingLot := {|->};
    public electricSlots : map location to parkingLot := {|->};
    public electricSlotsSeq : seq of location := [];
    public gasSlotsSeq : seq of location := [];

    public parkedCarsMap : map car`licenseplate to car := {|->};  -- Map for parked cars
    parkedCarsPlates: set of car`licenseplate := {};
    parkedCars: set of car := {};
    --parkedCars: map car`licenseplate to car := {|->};

    bank: real := 0.0;

inv bank >= 0.0;
inv dimensions > 0;

operations

-- flow of program
-- 1. initGarage
-- 2. can a car park
-- 3  park car
-- 4. remove car when leaving
-- 5. get time spent in garage
-- 6. pay when leaving

-- operation to init garage (garage is currently the controller, should make new class)
public initGarage: () ==> ()
initGarage() ==
(
    -- Initialize empty sequences
    electricSlotsSeq := [];
    gasSlotsSeq := [];

    -- Create electric and gas slots
    for i = 0 to dimensions-1 do
        for j = 0 to dimensions-1 do
            for k = 0 to dimensions-1 do
                if (i + j + k) mod 3 = 0 then
                (
                    -- Add to electric slots
                    let loc = mk_(i, j, k) in
                    (
                        electricSlots := electricSlots ++ {loc |-> mk_parkingLot(nil, loc, <electric>, 0)};
                        electricSlotsSeq := electricSlotsSeq ^ [loc];
                    )
                )
                else
                (
                    -- Add to gas slots
                    let loc = mk_(i, j, k) in
                    (
                        gasSlots := gasSlots ++ {loc |-> mk_parkingLot(nil, loc, <gas>, 0)};
                        gasSlotsSeq := gasSlotsSeq ^ [loc];
                    )
                );
);



--public initGarage: () ==> ()
--initGarage() ==
--(
--    -- Create electric slots for every 3rd spot
--    electricSlots := {mk_(i, j, k) |-> mk_parkingLot(nil, mk_(i, j, k), <electric>, 0) |
--                        i, j, k in set {0,...,dimensions} &
--                        ((i + j + k) mod 3 = 0)};
--    for all x in set dom electricSlots do
--        electricSlotsSeq := electricSlotsSeq ^ [x];
--
--    -- All other spots are gas
--    gasSlots := {mk_(i, j, k) |-> mk_parkingLot(nil, mk_(i, j, k), <gas>, 0) |
--                    i, j, k in set {0,...,dimensions}};
--
--    for all y in set dom gasSlots do
--        gasSlotsSeq := gasSlotsSeq ^ [y];
--
--);




-- operation to park a car in a slot
public parkCar: car * location ==> ()
parkCar(car, loc) ==
(   
    
    if loc in set dom gasSlots then
    (
        --IO`println("Parking car " ^ car.getPlate() ^ " in gas slot at " ^ natToString(loc.#1) ^ "," ^ natToString(loc.#2) ^ "," ^ natToString(loc.#3));
        --IO`println("Car " ^ car.getPlate() ^ " parked at time: " ^ natToString(world`timerRef.getTime()));

        gasSlots(loc).car := car;
        gasSlots(loc).time := world`timerRef.getTime();
        --IO`println("CarCurrentTime: " ^ natToString(car.getTime()));
        --car.setTime(world`timerRef.getTime());
    )
    elseif loc in set dom electricSlots then
    (
        --IO`println("Parking car " ^ car.getPlate() ^ " in electric slot at " ^ natToString(loc.#1) ^ "," ^ natToString(loc.#2) ^ "," ^ natToString(loc.#3));
        --IO`println("Car " ^ car.getPlate() ^ " parked at time: " ^ natToString(world`timerRef.getTime()));

        electricSlots(loc).car := car;
        electricSlots(loc).time := world`timerRef.getTime();
        --IO`println("CarCurrentTime: " ^ natToString(car.getTime()));

        --car.setTime(world`timerRef.getTime());

    );
)

pre loc.#1 >=0 and loc.#2 >=0 and loc.#3 >=0 and loc.#1 < dimensions+1 and loc.#2 < dimensions+1 and loc.#3 < dimensions+1;

public enterGarage: car ==> ()
enterGarage(car) ==
(      
    --IO`println("Total amount of spots" ^ natToString(card dom electricSlots + card dom gasSlots));
    
    
    --IO`println("GAS SLOTS" ^ natToString(card dom gasSlots));
    --IO`println("ELECTRIC SLOTS" ^ natToString(card dom electricSlots));
    --IO`println("PARKED CARD MAP " ^ natToString(card dom parkedCarsMap));
    --IO`println("MAX CAPACITY " ^ natToString(maxCapacity));
    if canPark(car) then
    (       
        if (fullnessRatio(card dom parkedCarsMap, getMaxCapacity()) > 0.7)  then
                    car.setFeeApplied(true);
        IO`println("RATIO IS: "^ realToString(fullnessRatio(card dom parkedCarsMap, getMaxCapacity())));
        let loc = findSlotSeq(car) in
        parkCar(car, loc);
        parkedCarsMap := parkedCarsMap ++ {car.getPlate() |-> car};  -- Add to map
        IO`println("Car PARKED  " ^ car.getPlate());
    )
    
)
pre card dom parkedCarsMap < maxCapacity and not carAlreadyExists(car.getPlate())
post carAlreadyExists(car.getPlate());


-- find available slot
public findSlot: car * seq of location * seq of location ==> location
findSlot(car, electricSlotSeq, gasSlotSeq) ==
(
    if car.getType() = <electric> then
    (
        if electricSlotSeq <> [] then
        (
            let first = hd electricSlotSeq in
            if isSlotFree(first) then
                return first
            else
                return findSlot(car, tl electricSlotSeq, gasSlotSeq)  -- Recurse to check the next electric slot
        )
        elseif gasSlotSeq <> [] then
        (
            let first = hd gasSlotSeq in
            if isSlotFree(first) then
                return first
            else
                return findSlot(car, electricSlotSeq, tl gasSlotSeq)  -- Recurse to check the next gas slot
        )
        else
            return mk_(-1, -1, -1);  -- No available slot found
    )
    elseif car.getType() = <gas> then
    (
        if gasSlotSeq <> [] then
        (
            let first = hd gasSlotSeq in
            if isSlotFree(first) then
                return first
            else
                return findSlot(car, electricSlotSeq, tl gasSlotSeq)  -- Recurse to check the next gas slot
        )
        else
            return mk_(-1, -1, -1);  -- No available slot found
    )
    else
        return mk_(-1, -1, -1)  -- Default case for unhandled types
);


public findSlotSeq : car ==> location
findSlotSeq(car) ==
(
    let electricSlotsSeqCopy = electricSlotsSeq, gasSlotsSeqCopy = gasSlotsSeq in
    return findSlot(car, electricSlotsSeqCopy, gasSlotsSeqCopy);
);

-- operation to check if car can park
public canPark: car ==> bool
canPark(car) ==
(
    if not carAlreadyExists(car.getPlate()) then
    (
        if findSlotSeq(car) <> mk_(-1, -1, -1) then
            return true
        else
            return false
    )
    else
        return false
);

public lookupCar: car`licenseplate ==> [car]
lookupCar(plate) ==
(
    if plate in set dom parkedCarsMap then
        return parkedCarsMap(plate)
    else
        return nil;
);

public leaveGarage: car`licenseplate ==> ()
leaveGarage(plate) ==
(
        
        let car = parkedCarsMap(plate) in
        
        (
            for all loc in set dom electricSlots do
            (   
                
                if electricSlots(loc).car = car then
                (   
                    
                    dcl timeSpent : nat := world`timerRef.getTime() - electricSlots(loc).time;
                    --IO`println("WORLD TIME" ^ natToString(world`timerRef.getTime()));
                    --IO`println("SLOT TIME" ^ natToString(electricSlots(loc).time));
                    --IO`println("ptime " ^ natToString(car.getTime()));
                    --IO`println("timeSpent " ^ natToString(timeSpent));
                    --let timeSpent = world`timerRef.getTime() - electricSlots(loc).time in  -- Use slot's entry time
                    car.addTime(timeSpent);  -- Accumulate time spent
                    --IO`println("ptimeNew " ^ natToString(car.getTime()));
                    --IO`println("Car " ^ car.getPlate() ^ " was parked for " ^ natToString(timeSpent) ^ " hours.");
                    
                    
                    let amount = pay(car) in  -- Calculate payment
                    updateBankBalance(amount);
                    electricSlots(loc).car := nil;  -- Free the slot
                    car.setLocation(-1, -1, -1);  -- Set car location to outside
                    parkedCarsMap := {plate} <-: parkedCarsMap;
                    IO`println("Fee Applied" ^ boolToString(car.getFeeApplied()));

                    return;  -- Exit after processing
                )
            )
        );
        
        let car = parkedCarsMap(plate) in

            for all loc in set dom gasSlots do
            (
                if gasSlots(loc).car = car then
                (
                    dcl timeSpent : nat := world`timerRef.getTime() - gasSlots(loc).time;
                    --IO`println("SLOT TIME" ^ natToString(gasSlots(loc).time));
                    --let timeSpent = world`timerRef.getTime() - electricSlots(loc).time in  -- Use slot's entry time
                    car.addTime(timeSpent);  -- Accumulate time spent
                    --IO`println("Car " ^ car.getPlate() ^ " was parked for " ^ natToString(timeSpent) ^ " hours.");
                    let amount = pay(car) in  -- Calculate payment
                    updateBankBalance(amount);
                    gasSlots(loc).car := nil;  -- Free the slot
                    car.setLocation(-1, -1, -1);  -- Set car location to outside
                    parkedCarsMap := {plate} <-: parkedCarsMap;
                )
                
            )
        
    
     
)
pre plate in set dom parkedCarsMap;


-- operation to get status of slot
public isSlotFree: location ==> bool
isSlotFree(loc) == (
    if loc in set dom gasSlots then
        return gasSlots(loc).car = nil  -- Check if gas slot is free
    elseif loc in set dom electricSlots then
        return electricSlots(loc).car = nil  -- Check if electric slot is free
    else return false;  -- Location is not part of the garage slots
);

-- operation to pay when leaving
public pay: car ==> real
pay(car) ==
(   
    dcl amount :real := 0;
    let timeSpent = car.getTime() in
    let feeApplied = car.getFeeApplied() in
    if feeApplied then
        amount:= fee * timeSpent * priceTypeCar(car)
    else
        amount := timeSpent * priceTypeCar(car);
    
    return amount;
);

public priceTypeCar : car ==> real
priceTypeCar(car) ==
    if car.getType() = <electric> then
        return electricParkingPrice
    else
        return gasParkingPrice;

private updateBankBalance: real ==> ()
updateBankBalance(amount) == (
    bank := bank + amount;

);

pure public carAlreadyExists: car`licenseplate ==> bool
carAlreadyExists(plate) == (
    return plate in set dom parkedCarsMap;
);

-- operation to pay when leaving the garage
pure public getBankBalance: () ==> real
getBankBalance() == (
    return bank;
);
public static natToString : nat ==> seq of char 
  natToString(n) ==
  (
   return VDMUtil`val2seq_of_char[nat](n);
  );
public static realToString : real ==> seq of char
realToString(n) ==
(
    return VDMUtil`val2seq_of_char[real](n);
);
public getMaxCapacity: () ==> nat
getMaxCapacity() == (
    return maxCapacity;
);

public static boolToString : bool ==> seq of char
boolToString(b) ==
(
    if b then
        return "1"
    else
        return "0";
);
functions

fullnessRatio: nat * nat -> real
fullnessRatio(n, max) == 
    n / max
    pre n <= max and max > 0 and n >= 0;
end controller
\end{vdm_al}
\end{document}
