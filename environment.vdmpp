class environment
types
    public Time = nat;
    public inline = car`licenseplate * car`typeCar;
    public outline = car`licenseplate * Time * real;
    public carEntry = car`licenseplate * car`typeCar * Time * Time;


instance variables
    io : IO := new IO();
    endSimTime : Time := 5;
    carSchedule : seq of carEntry := [];
    outlines : seq of outline := [];
    parked : seq of carEntry := [];
    controllerRef : controller;
    alreadyPrintedEmpty : bool := false;
operations

public environment : seq of char * controller ==> environment
environment(file, controllerInit) ==
(
    controllerRef := controllerInit;
    def mk_(-, input) = io.freadval[seq of carEntry](file) 
    in
        carSchedule := input;
);
public Simulate : () ==> ()
    Simulate() ==
    (world`timerRef.SetEndSimTime(endSimTime);
    while world`timerRef.getTime() < endSimTime do
    (
        updateGarage();
        world`timerRef.Step();
        printParkedCars();
    );

    report();
    
    );
public printParkedCars: () ==> ()
printParkedCars() ==
(
    IO`println("Current Cars in the Garage:");
    IO`println("-----------------------------------");
    IO`println("Current time:");
    IO`println(world`timerRef.getTime());
    for car in parked do
    (
        IO`println("Car Plate: " ^ car.#1);
        IO`println("Car Type: " ^ (if car.#2 = <electric> then "Electric" else "Gas"));
        IO`println("Entered at Time:");
        IO`println(car.#3);
        IO`println("Expected Leave Time:");
        IO`println(car.#4);
        IO`println("-----------------------------------");
    );

    if parked = [] and not alreadyPrintedEmpty then
        (
        IO`println("No cars in the garage.");
        alreadyPrintedEmpty := true;
    );
    
);

public updateGarage: () ==> ()
updateGarage() == (
    -- Process any cars scheduled to enter at the current time
    if carSchedule <> [] then
    (
        let carEntry = hd carSchedule in
        if carEntry.#3 = world`timerRef.getTime() then
        (
            
            dcl newCar : car := new car(carEntry.#1, mk_(-1, -1, -1), carEntry.#3, carEntry.#2);
    
            controllerRef.enterGarage(newCar);
            parked := parked ^ [carEntry];  
            carSchedule := tl carSchedule; 
        )
    );

    -- Process any cars scheduled to exit at the current time
    for i = 1 to len parked do
    (
        let parkedCar = parked(i) in
        if parkedCar.#4 = world`timerRef.getTime() then
        (
            dcl carToExit : [car] := controllerRef.lookupCar(parkedCar.#1);  -- Find the car by plate
            if carToExit <> nil then
              controllerRef.leaveGarage(carToExit)  -- Remove the car from the garage
            
        )
    )
);

public report: () ==> ()
report() ==
(
    IO`println("Report: Cars Leaving and Payments Summary");
    IO`println("------------------------------------------");    

);


end environment