class controller
types
public location = real * real * real;
public parkingLot ::
        car : [car]
        pos : location
        typeOfSlot : <electric> | <gas>
        time : nat
instance variables
    dimensions: nat := 2;
    maxCapacity: nat := dimensions**3;

    fee: real :=1.15; -- % added to the price of parking
    electricParkingPrice: real := 1.0;
    gasParkingPrice: real := 5.0;

    
    gasSlots : map location to parkingLot := {|->};
    electricSlots : map location to parkingLot := {|->};

    parkedCarsPlates: set of car`licenseplate := {};
    parkedCars: set of car := {};

    bank: real := 0.0;

operations

-- flow of program
-- 1. initGarage
-- 2. can a car park
-- 3  park car
-- 4. remove car when leaving
-- 5. get time spent in garage
-- 6. pay when leaving

-- operation to init garage (garage is currently the controller, should make new class)
public initGarage: () ==>()
initGarage() == (
    for i = 0 to dimensions do
        for j = 0 to dimensions do
            for k = 0 to dimensions do
            if i = dimensions  or j = dimensions or k = dimensions then 
                electricSlots := electricSlots ++ {mk_(i, j, k) |-> mk_parkingLot(nil, mk_(i, j, k), <electric>, 0 )} -- edge slots are electric
            else
                gasSlots := gasSlots ++ {mk_(i, j, k) |-> mk_parkingLot(nil, mk_(i, j, k), <gas>, 0 )} -- other slots are gas
);

--public initGarage: () ==> ()
--initGarage() ==
--(
--    electricSlots := {mk_(i, j, k) |-> mk_parkingLot(nil, mk_(i, j, k), <electric>, 0) |
--                        i, j, k in set {0,...,dimensions} & 
--                        (i = dimensions or j = dimensions or k = dimensions)};
--
--    gasSlots := {mk_(i, j, k) |-> mk_parkingLot(nil, mk_(i, j, k), <gas>, 0) |
--                    i, j, k in set {0,...,dimensions} & 
--                    not (i = dimensions or j = dimensions or k = dimensions)};
--);


-- operation to park a car in a slot
public parkCar: car * location ==> ()
parkCar(car, loc) ==
(
    if loc in set dom gasSlots then
    (
        parkedCars := parkedCars union {car};
        parkedCarsPlates := parkedCarsPlates union {car.getPlate()};
        car.setLocation(loc.#1, loc.#2, loc.#3);
        gasSlots(loc).time := world`timerRef.getTime(); -- Update the time
    )
    elseif loc in set dom electricSlots then
    (
        parkedCars := parkedCars union {car};
        parkedCarsPlates := parkedCarsPlates union {car.getPlate()};
        car.setLocation(loc.#1, loc.#2, loc.#3);
        electricSlots(loc).time := world`timerRef.getTime();  -- Update the time
    )
)
pre loc.#1 >=0 and loc.#2 >=0 and loc.#3 >=0 and loc.#1 < dimensions+1 and loc.#2 < dimensions+1 and loc.#3 < dimensions+1;

public enterGarage: car ==> ()
enterGarage(car) == (
    if canPark(car) then
    (
        let loc = findSlot(car) in
        parkCar(car, loc);
    )
    -- else would like to error handle here
)
pre car.getPlate() <> [] and car.getPlate() not in set parkedCarsPlates;

-- find available slot
public findSlot: car ==> location
findSlot(car) == (
    if car.getType() = <electric> then
        for all loc in set dom electricSlots do
        if isSlotFree(loc)  then
            return loc
    else
        for all loc in set dom gasSlots do
        if isSlotFree(loc) then
            return loc;

    if car.getType() = <gas> then
        for all loc in set dom gasSlots do
        if isSlotFree(loc) then
            return loc;
    return mk_(-1,-1,-1); 
)
pre card parkedCarsPlates < maxCapacity+1;


-- operation to check that no parkingSlot has a parked car for too long
-- if a car has been parked too long, a fee is added to its final bill
-- TODO

public checkSlots: () ==> ()
checkSlots() == (
    let parkingSlots = electricSlots munion gasSlots in
    for all loc in set dom parkingSlots do
        if not isSlotFree(loc) then
            if world`timerRef.getTime() - parkingSlots(loc).time > 4 then
                parkingSlots(loc).car.setFeeApplied(true); 
);


-- operation move car from electric slot to gas slot, from a single location
-- TODO

-- operation to check if car exists in garage already


-- operation to check if car can park
public canPark: car ==> bool
canPark(car) == (
    return not carAlreadyExists(car.getPlate()) and findSlot(car) <> mk_(-1,-1,-1);
);

-- operation to remove a car from garage

public lookupCar: car`licenseplate ==> [car]
  lookupCar(plate) ==
(
    for all car in set parkedCars do
        if car.getPlate() = plate then
            return car;
    return nil;  -- Return nil if no match is found
);

public leaveGarage: car ==> ()
leaveGarage(car) == (
    parkedCars := parkedCars \ {car};
    parkedCarsPlates := parkedCarsPlates \ {car.getPlate()};
    if car.getType() = <electric> then
    (
        for all loc in set dom electricSlots do
        (
            if electricSlots(loc).car = car then
            (
                electricSlots(loc).car := nil;
                car.addTime(world`timerRef.getTime() - electricSlots(loc).time);
                updateBankBalance(pay(car)); -- pay the price for parking
                car.setLocation(-1, -1, -1); -- Set to outside garage
            )
        )
    )
    else
    (
        for all loc in set dom gasSlots do
        (
            if gasSlots(loc).car = car then
            (
                gasSlots(loc).car := nil;
                car.addTime(world`timerRef.getTime() - gasSlots(loc).time);
                updateBankBalance(pay(car));
                car.setLocation(-1, -1, -1); -- Set to outside garage
            )
        )
    )
)
pre car in set parkedCars
post parkedCars = parkedCars \ {car} and car.getLocation() = mk_(-1,-1,-1);


-- operation to get status of slot
public isSlotFree: location ==> bool
isSlotFree(loc) == (
    if loc in set dom gasSlots then
        return gasSlots(loc).car = nil  -- returns true if slot is free
    else
        return  electricSlots(loc).car = nil  -- returns true if slot is free
);

-- operation to pay when leaving
public pay: car ==> real
pay(car) ==
(
    let timeSpent = car.getTime() in
    let feeApplied = car.getFeeApplied() in
    if feeApplied then
        return fee * timeSpent * priceTypeCar(car)
    else
        return timeSpent * priceTypeCar(car);
);

public priceTypeCar : car ==> real
priceTypeCar(car) ==
    if car.getType() = <electric> then
        return electricParkingPrice
    else
        return gasParkingPrice;

private updateBankBalance: real ==> ()
updateBankBalance(amount) == (
    bank := bank + amount;
);

pure public carAlreadyExists: car`licenseplate ==> bool
carAlreadyExists(plate) == (
    return plate in set parkedCarsPlates;
);

-- operation to pay when leaving the garage
pure public getBankBalance: () ==> real
getBankBalance() == (
    return bank;
);

end controller