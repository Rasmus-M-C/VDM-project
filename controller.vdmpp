class controller
types
public location = real * real * real;
public parkingLot ::
        car : [car]
        pos : location
        typeOfSlot : <electric> | <gas>
        time : nat
instance variables
    io : IO := new IO();
    dimensions: nat := 2;
    maxCapacity: nat := (dimensions**3)+1;

    fee: real :=1.15; -- % added to the price of parking
    electricParkingPrice: real := 1.0;
    gasParkingPrice: real := 5.0;

    
    public gasSlots : map location to parkingLot := {|->};
    public electricSlots : map location to parkingLot := {|->};
    electricSlotsSeq : seq of location := [];
    gasSlotsSeq : seq of location := [];

    public parkedCarsMap : map car`licenseplate to car := {|->};  -- Map for parked cars
    parkedCarsPlates: set of car`licenseplate := {};
    parkedCars: set of car := {};
    --parkedCars: map car`licenseplate to car := {|->};

    bank: real := 0.0;

inv bank >= 0.0;
inv dimensions > 0;

operations

-- flow of program
-- 1. initGarage
-- 2. can a car park
-- 3  park car
-- 4. remove car when leaving
-- 5. get time spent in garage
-- 6. pay when leaving

-- operation to init garage (garage is currently the controller, should make new class)
public initGarage: () ==> ()
initGarage() ==
(
    -- Iterate through the dimensions and add slots to the maps and sequences
    for i = 0 to dimensions do
        for j = 0 to dimensions do
            for k = 0 to dimensions do
                if i = dimensions or j = dimensions or k = dimensions then 
                (
                    -- Add electric slot
                    electricSlots := electricSlots ++ {mk_(i, j, k) |-> mk_parkingLot(nil, mk_(i, j, k), <electric>, 0)};
                    electricSlotsSeq := electricSlotsSeq ^ [mk_(i, j, k)];
                )
                else
                (
                    -- Add gas slot
                    gasSlots := gasSlots ++ {mk_(i, j, k) |-> mk_parkingLot(nil, mk_(i, j, k), <gas>, 0)};
                    gasSlotsSeq := gasSlotsSeq ^ [mk_(i, j, k)];
                );
);


--public initGarage: () ==> ()
--initGarage() ==
--(
--    electricSlots := {mk_(i, j, k) |-> mk_parkingLot(nil, mk_(i, j, k), <electric>, 0) |
--                        i, j, k in set {0,...,dimensions} & 
--                        (i = dimensions or j = dimensions or k = dimensions)};
--
--    gasSlots := {mk_(i, j, k) |-> mk_parkingLot(nil, mk_(i, j, k), <gas>, 0) |
--                    i, j, k in set {0,...,dimensions} & 
--                    not (i = dimensions or j = dimensions or k = dimensions)};
--);


-- operation to park a car in a slot
public parkCar: car * location ==> ()
parkCar(car, loc) ==
(
    if loc in set dom gasSlots then
    (
        --IO`println("Parking car " ^ car.getPlate() ^ " in gas slot at " ^ natToString(loc.#1) ^ "," ^ natToString(loc.#2) ^ "," ^ natToString(loc.#3));
        --IO`println("Car " ^ car.getPlate() ^ " parked at time: " ^ natToString(world`timerRef.getTime()));

        gasSlots(loc).car := car;
        gasSlots(loc).time := world`timerRef.getTime();
        --IO`println("CarCurrentTime: " ^ natToString(car.getTime()));
        --car.setTime(world`timerRef.getTime());
    )
    elseif loc in set dom electricSlots then
    (
        --IO`println("Parking car " ^ car.getPlate() ^ " in electric slot at " ^ natToString(loc.#1) ^ "," ^ natToString(loc.#2) ^ "," ^ natToString(loc.#3));
        --IO`println("Car " ^ car.getPlate() ^ " parked at time: " ^ natToString(world`timerRef.getTime()));

        electricSlots(loc).car := car;
        electricSlots(loc).time := world`timerRef.getTime();
        --IO`println("CarCurrentTime: " ^ natToString(car.getTime()));

        --car.setTime(world`timerRef.getTime());

    );
)

pre loc.#1 >=0 and loc.#2 >=0 and loc.#3 >=0 and loc.#1 < dimensions+1 and loc.#2 < dimensions+1 and loc.#3 < dimensions+1;

public enterGarage: car ==> ()
enterGarage(car) ==
(   
    IO`println("parkedCarMap+1 " ^ natToString(card dom parkedCarsMap));
    IO`println("CAPACIOTY " ^ natToString(getMaxCapacity()));

    if canPark(car) then
    (   
        
        let loc = findSlotSeq(car) in
        parkCar(car, loc);
        parkedCarsMap := parkedCarsMap ++ {car.getPlate() |-> car};  -- Add to map
        IO`println("parkedCarMap+1 AFTER" ^ natToString(card dom parkedCarsMap));
    )
    else
        IO`println("Car " ^ car.getPlate() ^ " cannot park.");
)
pre card dom parkedCarsMap < maxCapacity;


-- find available slot
public findSlot: car * seq of location * seq of location ==> location
findSlot(car, electricSlotSeq, gasSlotSeq) ==
(
    if car.getType() = <electric> then
    (
        if electricSlotSeq <> [] then
        (
            let first = hd electricSlotSeq in
            if isSlotFree(first) then
                return first
            else
                return findSlot(car, tl electricSlotSeq, gasSlotSeq)  -- Recurse to check the next electric slot
        )
        elseif gasSlotSeq <> [] then
        (
            let first = hd gasSlotSeq in
            if isSlotFree(first) then
                return first
            else
                return findSlot(car, electricSlotSeq, tl gasSlotSeq)  -- Recurse to check the next gas slot
        )
        else
            return mk_(-1, -1, -1);  -- No available slot found
    )
    elseif car.getType() = <gas> then
    (
        if gasSlotSeq <> [] then
        (
            let first = hd gasSlotSeq in
            if isSlotFree(first) then
                return first
            else
                return findSlot(car, electricSlotSeq, tl gasSlotSeq)  -- Recurse to check the next gas slot
        )
        else
            return mk_(-1, -1, -1);  -- No available slot found
    )
    else
        return mk_(-1, -1, -1)  -- Default case for unhandled types
);


public findSlotSeq : car ==> location
findSlotSeq(car) ==
(
    let electricSlotsSeqCopy = electricSlotsSeq, gasSlotsSeqCopy = gasSlotsSeq in
    return findSlot(car, electricSlotsSeqCopy, gasSlotsSeqCopy);
);






-- operation to check that no parkingSlot has a parked car for too long
-- if a car has been parked too long, a fee is added to its final bill
-- TODO

public checkSlots: () ==> ()
checkSlots() == (
    let parkingSlots = electricSlots munion gasSlots in
    for all loc in set dom parkingSlots do
        if not isSlotFree(loc) then
            if world`timerRef.getTime() - parkingSlots(loc).time > 4 then
                parkingSlots(loc).car.setFeeApplied(true); 
);


-- operation move car from electric slot to gas slot, from a single location
-- TODO

-- operation to check if car exists in garage already


-- operation to check if car can park
public canPark: car ==> bool
canPark(car) == (
    return not carAlreadyExists(car.getPlate()) and findSlotSeq(car) <> mk_(-1,-1,-1);
)
pre card dom parkedCarsMap+1 <= maxCapacity;

-- operation to remove a car from garage

public lookupCar: car`licenseplate ==> [car]
lookupCar(plate) ==
(
    if plate in set dom parkedCarsMap then
        return parkedCarsMap(plate)
    else
        return nil;
);

public leaveGarage: car`licenseplate ==> ()
leaveGarage(plate) ==
(
    

    if plate in set dom parkedCarsMap then
    (   
        
        let car = parkedCarsMap(plate) in
        
        (
            for all loc in set dom electricSlots do
            (   
                
                if electricSlots(loc).car = car then
                (   
                    
                    dcl timeSpent : nat := world`timerRef.getTime() - electricSlots(loc).time;
                    --IO`println("WORLD TIME" ^ natToString(world`timerRef.getTime()));
                    --IO`println("SLOT TIME" ^ natToString(electricSlots(loc).time));
                    --IO`println("ptime " ^ natToString(car.getTime()));
                    --IO`println("timeSpent " ^ natToString(timeSpent));
                    --let timeSpent = world`timerRef.getTime() - electricSlots(loc).time in  -- Use slot's entry time
                    car.addTime(timeSpent);  -- Accumulate time spent
                    --IO`println("ptimeNew " ^ natToString(car.getTime()));
                    --IO`println("Car " ^ car.getPlate() ^ " was parked for " ^ natToString(timeSpent) ^ " hours.");
                    let amount = pay(car) in  -- Calculate payment
                    updateBankBalance(amount);
                    electricSlots(loc).car := nil;  -- Free the slot
                    car.setLocation(-1, -1, -1);  -- Set car location to outside
                    parkedCarsMap := {plate} <-: parkedCarsMap;

                    return;  -- Exit after processing
                )
            )
        );
        
        let car = parkedCarsMap(plate) in

            for all loc in set dom gasSlots do
            (
                if gasSlots(loc).car = car then
                (
                    dcl timeSpent : nat := world`timerRef.getTime() - gasSlots(loc).time;
                    --IO`println("SLOT TIME" ^ natToString(gasSlots(loc).time));
                    --let timeSpent = world`timerRef.getTime() - electricSlots(loc).time in  -- Use slot's entry time
                    car.addTime(timeSpent);  -- Accumulate time spent
                    --IO`println("Car " ^ car.getPlate() ^ " was parked for " ^ natToString(timeSpent) ^ " hours.");
                    let amount = pay(car) in  -- Calculate payment
                    updateBankBalance(amount);
                    gasSlots(loc).car := nil;  -- Free the slot
                    car.setLocation(-1, -1, -1);  -- Set car location to outside
                    parkedCarsMap := {plate} <-: parkedCarsMap;
                )
                
            )
        
    )
     
)
pre plate in set dom parkedCarsMap;




-- operation to get status of slot
public isSlotFree: location ==> bool
isSlotFree(loc) == (
    if loc in set dom gasSlots then
        return gasSlots(loc).car = nil  -- Check if gas slot is free
    elseif loc in set dom electricSlots then
        return electricSlots(loc).car = nil  -- Check if electric slot is free
    else return false;  -- Location is not part of the garage slots
);

-- operation to pay when leaving
public pay: car ==> real
pay(car) ==
(   
    dcl amount :real := 0;
    let timeSpent = car.getTime() in
    let feeApplied = car.getFeeApplied() in
    if feeApplied then
        amount:= fee * timeSpent * priceTypeCar(car)
    else
        amount := timeSpent * priceTypeCar(car);
    --IO`println("Amount to pay: " ^ realToString(amount));
    return amount;
);




public priceTypeCar : car ==> real
priceTypeCar(car) ==
    if car.getType() = <electric> then
        return electricParkingPrice
    else
        return gasParkingPrice;

private updateBankBalance: real ==> ()
updateBankBalance(amount) == (
    bank := bank + amount;

);

pure public carAlreadyExists: car`licenseplate ==> bool
carAlreadyExists(plate) == (
    return plate in set dom parkedCarsMap;
);

-- operation to pay when leaving the garage
pure public getBankBalance: () ==> real
getBankBalance() == (
    return bank;
);
public static natToString : nat ==> seq of char 
		natToString(n) ==
		(
			return VDMUtil`val2seq_of_char[nat](n);
		);
public static realToString : real ==> seq of char
realToString(n) ==
(
    return VDMUtil`val2seq_of_char[real](n);
);
public getMaxCapacity: () ==> nat
getMaxCapacity() == (
    return maxCapacity;
);

functions

end controller